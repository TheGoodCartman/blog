<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.515">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>The KingOli Blog - The Legend of Zelda: Breath of the Wild</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<link href="../../../../k-typewriter.png" rel="icon" type="image/png">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../k-typewriter.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">The KingOli Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/TheGoodCartman"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The Legend of Zelda: Breath of the Wild</h1>
  <div class="quarto-categories">
    <div class="quarto-category">gespielt</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">10.10.2021 16:01</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Vor ungefähr 30 Jahren war Teil 1 der Zelda-Reihe auf dem NES mein allererstes Open-World-Spiel - auch wenn ich den Begriff zu der Zeit nicht kannte. Damals wurde ich als Spieler mit einer sehr rudimentären Handlung in eine Welt geworfen, die ich zwar theoretisch von Anfang an komplett erkunden konnte, die aber schnell aufzeigte, wo der Charakter Link seine Grenzen hat. Erst mit wachsendem Waffenarsenal aus den Dungeons war der Held wirklich für viele Bereiche gerüstet, und einiges im Spiel war so gut versteckt, dass ich ohne einen Spieleführer nicht weit gekommen wäre.</p>
<p>Die Rückkehr der Zelda-Reihe in das Open-World-Genre ließ die Erinnerungen an meinen ersten Ausflug nach Hyrule wach werden. Gerade zu Beginn des Spiels fühlte ich mich verloren in der großen, teilweise unverständlichen Welt. War die knappe Story in den 80ern nicht ungewöhnlich, sind die kargen Happen, die Breath of the Wild dem Spieler hinwirft, heutzutage sehr irritierend, gerade verglichen mit Storymonstern wie RDR oder Skyrim.</p>
<p>In der ersten Spielstunde trifft Link auf genau einen NPC, und dessen Dialoge sind nicht einmal vertont. Dies trifft auf den Großteil der Gespräche im Spiel zu - das ist ganz und gar nicht zeitgemäß. Dieser Charakter erklärt dem Spieler einige Game-Mechaniken, doch schon in dieser Erklärphase des Spiels in einem begrenzten Bereich der Welt zeigt Breath of the Wild, dass es es dem Spieler niemals einfach machen wird. Freie Exploration ist quasi das Grundgerüst des Spiels, nur selten wurde ich explizit irgendwo hingeschickt, um etwas zu tun.</p>
<p>Schnell lernte ich, dass sich die meisten Waffen sehr schnell abnutzen (sehr ärgerlich), dass mit Klettern (und ausreichend Ausdauer) eigentlich jeder Ort von Hyrule erreicht werden kann und dass es kalte, warme und heiße Gegenden gibt, die spezielle Kleidung oder Nahrung erfordern, um dort zu überleben.</p>
<p>Dabei hatte ich gleich meinen ersten Frustmoment im Spiel. Von einem Buch in einer Försterhütte erfuhr ich, dass ich ein Ziel oben auf einem Berg nur mit einem speziellen Gericht gegen die Kälte erreichen kann. Für dessen Herstellung muss ich Wild mit einer unbekannten Zutat mischen. Dumm war nur: An der Jagdstelle wollte lange Zeit kein Wild zum Jagen auftauchen (Bug?). Und dann wusste ich immer noch nicht, was die unbekannte Zutat ist. Dieses “Probieren geht über Studieren” ist ein Grundprinzip des Spiels, aber hier war es zwingend zum Weiterkommen notwendig. Da ich so wenig Wild hatte, ging das nur über Speichern und Neuladen. Nach drei Stunden Frust griff ich deshalb zum ersten Mal nach dem Ratgeber Internet - im erweiterten Intro eines Spiels sollte das eigentlich nicht notwendig sein.</p>
<p>Nach dieser etwas holprigen Einführung wurde es zum Glück besser: Die anfangs leer wirkende Welt hat neben vielen Monstern auch ein paar Dörfer zu bieten und zu meiner Verwirrung ein knappes Dutzend Ställe. Dort finden sich dann endlich auch ein paar Quests abseits der Hauptstory, d.h. es gibt endlich etwas Struktur neben dem freien Erkunden. So kam ich ziemlich schnell zu einem der vier Endbosse - Titanen genannte Riesenmaschinen, die erst in Betrieb genommen werden müssen, um danach einen vom Oberbösewicht Ganon gesandten Fluch zu besiegen.</p>
<p>Bei meinem ersten Versuch, den Wasserfluch Ganons im Titan Vah Ruta zu besiegen, lernte ich aber schnell: Ich war zu früh und unvorbereitet in die Aufgabe gerannt. Denn auch wenn Breath of the wild ein Action Adventure ist und deshalb Erfahrungen sammeln und Fähigkeiten ausbauen kein Spielinhalt sind, so gibt es doch mit den Herzen und der Ausdauer Attribute, die zwingend erhöht werden müssen, um gegen die Endbosse anzukommen.</p>
<p>Und wie kommt man zu diesen Updates? Da kommt wieder die explorative Spielmechanik zum Tragen: In ganz Hyrule sind über 100 Schreine mehr oder weniger gut versteckt, in denen Jahrtausende alte mumifizierte Priester mit für Action Adventures üblichen Rätseln dem Spieler Herausforderungen stellen, deren Lösung mit einem sogenannten Zeichen der Bewährung belohnt wird. Und je vier dieser Zeichen können an Statuen der Göttin Hylia gegen einen weiteren Herz- oder Ausdauercontainer eingetauscht werden.</p>
<p>Warum? Was hat die Göttin mit den Mumien zu tun? Weshalb wurden vor zehntausend Jahren riesige unterirdische Rätsel gebaut? Das wird im Spiel nicht geklärt. Aber wer nachrechnet wird merken, dass einige Schreine gelöst werden müssen, um Link substantiell zu stärken. Ich war am Ende bei 70 Schreinen angelangt. Und da sich die Schreine über die gesamte Karte verteilen, kommt man gar nicht umher, alle Gebiete von Hyrule zu erkunden.</p>
<p>Und beim Erkunden findet man so viel mehr als nur die Schreine, die auch als Schnellreisepunkte dienen. Z.B. die Krogs, kleine Blattwesen, die sich unter Steinen und hinter kleinen Rätseln verstecken, und deren Belohnung wiederum in größere Taschen für z.B. Waffen eingetauscht werden können.</p>
<p>Wo andere Spiele also über Storyquests verlangen, dass ein Spieler bestimmte Anforderungen erfüllt, macht BotW dies sehr indirekt und erwartet gleichzeitig, dass die Spielewelt mit Neugierde erkundet wird. Zu den meisten Seltsamkeiten findet sich irgendwo ein NPC, der etwas dazu zu sagen hat. Leider sind manche Beschreibungen (z.B. von Türmen) sehr mehrdeutig und die Questmarker zeigen auf den Auftraggeber, aber nicht auf das Ziel.</p>
<p>Ansonsten ist Hyrule überaschend zugänglich. Mit der zum Klima passenden Kleidung kann Link durch seine Kletterfähigkeit jeden Berg erklimmen und muss sich deshalb theoretisch nicht an die vorgegebenen Wege durch Hyrule halten. Praktisch entdeckt man die Ställe und Hinweise auf Schreine hauptsächlich an den Wegen, so dass es sinnvoll ist, diese alle einmal abzulaufen. Oder zu reiten - allerdings empfand ich das Fangen und Einreiten wenig motivierend und war deshalb fast ausschließlich per pedes unterwegs.</p>
<p>Und wie bei den meisten Open-World-Spielen nagt dieses alles-erlaufen-können doch merklich an der Glaubwürdigkeit der Spielewelt. Innerhalb weniger Laufminuten wechseln sich nicht nur extreme Klimazonen ab (inkl. Phänomenen wie dass lokal im Sandsturm die Sicht sehr schlecht ist, von weit weg das Gebiet aber per Fernglas eingesehen werden kann), sondern auch sehr unterschiedliche Völker und Dörfer, die die (respawnenden) Monster außerhalb der Tore seltsamerweise kaum tangieren.</p>
<p>Optisch schön ist das Wetter in BotW umgesetzt. Im Regen leidet Links Kletterfähigkeit und bei Gewittern ziehen metallene Waffen Blitze an, aber nur so lange man sie offen am Körper trägt. Sobald sie in der Tasche verschwinden, ist das kein Problem mehr. Allerdings erfordern einige Quests schönes Wetter (die blaue Flamme), und mindestens einmal musste ich minutenlang auf besseres Wetter warten.</p>
<p>Das sind dann die Momente, wo die Spielelemente von BotW nicht so gut ineinandergreifen, wie sie könnten. So toll Link klettern kann, in den Schreinen funktioniert dies nicht - denn dann wären die Rätsel meist einfacher zu lösen. Beim Kochen können nicht nur Gerichte entstehen, sondern auch Tränke, aber wieso es zusätzlich zu den Kochschalen auch noch die Möglichkeit gibt, Zutaten am Feuern zu rösten, hat sich mir nicht erschlossen.</p>
<p>Verbesserungswürdig fand ich auch das User Interface. Die ungenauen Analogssticks fallen eigentlich nur bei den Bosskämpfen negativ auf. Richtig gefreut hätte ich mich aber über mehr Einblick in die Haltbarkeit der Waffen. Erst kurz vor dem Zerbrechen gibt es einen Hinweis darauf. D.h. man schleppt zwar ein Arsenal an Waffen mit sich herum, aber ob es für die anstehenden Aufgaben reicht, kann man nur abschätzen. Zusammen mit den steigenden Preisen für die Erweiterung der Taschen verwaltet man als Spieler eigentlich ständig nur den Mangel und steht gefühlt alle 10min vor der Entscheidung, eine vielleicht bald kaputt gehende Waffe gegen eine schwächere, aber möglicherweise längere haltende Alternative einzutauschen. Wie habe ich mir eine Schmiedeoption gewünscht, um die Haltbarkeit meiner Lieblingswaffen zu verlängern.</p>
<p>Bis knapp vor dem Ende des Spiels war ich auch immer knapp bei Kasse, da die für die verschiedenen Klimazonen wichtige Kleidung ebenso wie deren Aufrüstung Geld kostet und es immer ungewiss bleibt, ob die gefundenen Zutaten im Inventar für Quests benötigt werden oder verkauft werden können - wobei nur weniges wirklich gute Preise erzielt. Dadurch wird auch der eigentlich mächtige Bogen abgewertet, da Pfeile teuer im Einkauf und so ständig Mangelware sind.</p>
<p>Fazit: In vielen Medien wurde BotW als das beste Spiel für die Switch bezeichnet. Außer bei der Grafik kann ich diese Einschätzung nicht nachvollziehen. Ja, es bietet ein tolles Spielerlebnis und hat einen großen Umfang, aber gleichzeitig gibt es viele Ecken und Kanten, die mich frustrierten. Das aufs Erkunden bauende Spielprinzip wird über alles gestellt, und dafür sogar eine motivierenden Story geopfert.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>